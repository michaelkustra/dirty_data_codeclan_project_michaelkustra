---
title: "String Basics"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    df_print: paged
    css: ../../../styles.css
  pdf_document: default
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align = 'center')
```

# Learning Objectives:

* Define strings in R
* Concatenate strings
* Format numbers as strings
* Work with strings in a dataset


**Lesson Duration: 60 mins**

Although much of the data you will encounter in your career will take numerical forms, it's not the only sort you'll come across. Text will also play a part, both in terms of presentation and (perhaps more importantly) in data sources. Text mining in particular will require lots of work with strings, you'll find out more about this later in the course. 

In this lesson we'll look at some of the tools in R for working with strings.

# Storing Strings in Variables

Just like anything else in R, we can store a string in a variable. We define the string using quotation marks: either single (`''`) or double (`""`).

```{r}
single_quote_string <- 'This is a single-quote string'
double_quote_string <- "Double-quotes work just as well"

single_quote_string
double_quote_string
```


It makes no difference if we use single or double quotes; both are valid ways of defining strings. However, we need to take care when we want to include a quotation mark **inside** a string. As you have no doubt discovered by now, computers will only do what we tell them to do. If we, for example, try to use a single quote inside a single-quoted string then knitr will interpret that quote as the end of the string. This is a particularly common problem when we want to include an apostrophe in text.

```{r}
mixed_string <- "If I use a single quote inside double quotes it'll be fine, though."
escaped_string <- 'I won\'t have any problems if I escape using a backslash before the quote.'

mixed_string
escaped_string
```

Because of this we recommend using double-quotes for strings where possible, and this is also consistent with our coding style guide. 




## What can a string contain?

Strings can contain anything - numbers, characters, or nothing. A string with nothing in it has a special name: the **empty string**. Note that this **isn't the same** as a string which only contains white space! Sometimes it can be hard to see the difference but let's take a look at an example:

```{r, message=FALSE}
library(tidyverse)
```

```{r}
employees <- tibble(
  first_name = c("Sally", "steven", "Mary", "John"),
  last_name = c("Smith", "hasTings", "Milne", "Davidson"),
  postcode = c("EH10 6GH", "EH3 7HL", "G1 7FR", NA), 
  location = c(" ", "Edinburgh", "", "Stirling")
)

employees
```

Mary has an empty string as her location and Sally does not, it's a string containing a white space. From visually looking at the tibble output it's hard to tell they are different (and we may not have coded the table) we would be able to see from doing a `group_by()` on the `location` column that these are not the same:

```{r}
employees %>%
  group_by(location) %>%
  summarise(count = n())
```

but if we check we can see they are not equal:

```{r}
mary_location <- employees %>%
  filter(first_name == "Mary") %>%
  select(location) %>%
  pull()

sally_location <- employees %>%
  filter(first_name == "Sally") %>%
  select(location) %>%
  pull()

mary_location == sally_location
```

# Manipulating Strings

It's very unlikely that we'll be happy with the strings we dig out of our datasets. We'll probably want to extract certain parts of them, or get rid of excess whitespace, or alter them in some other way. There's a library we can use to help us do this called `stringr` which will have been installed as part of your work with `tidyverse` earlier in the week.

```{r, message = FALSE, warning = F}
library(tidyverse)
```


```{r, echo=FALSE, out.width = '50%'}
knitr::include_graphics("images/logo.png")
```



## Concatenating

Arguably the simplest way of altering strings is to stick two of them together. We call this **concatenating** strings (the operation is known as **concatenation**).

Let's start small by building a short phrase: `stringr` has two functions which we can use here, both of which do the same thing: `str_c()` and `str_join()`. We'll use `str_c()` throughout this lesson and others today, but the two functions are interchangeable.

```{r}
str_c("This", "is", "some", "text")
```

We can also apply it to our `employees` dataset, let's say we want to combine their first and last name into a column called `full_name`.

If we think back to last week, we learned that the `mutate` function allows us to create new columns, or overwrite existing ones. If you want to use the functions from `stringr` across a column you need to use them with `mutate`. Remember, the first argument to mutate is always the column name. This will either be a new name (as we've done here), or a name of an existing column you want to overwrite.

```{r}
employees %>%
  mutate(full_name = str_c(first_name, last_name)) 
```


Hmmm, it's not quite the result we are looking for, but since we haven't told the function to do anything different it's just mashing the columns together. We can tell them to put something between each string by passing a value to the `sep` parameter (short for **separator**). This can be anything we like, so long as it's a string.


```{r}
employees %>%
  mutate(full_name = str_c(first_name, last_name, sep = " ")) 
```

```{r}
employees %>%
  mutate(full_name = str_c(first_name, last_name, sep = "_")) 
```


`str_c()` has another useful feature: any `NULL` passed in to it will be ignored automatically rather than setting the whole value to `NULL`.

```{r}
employees %>%
  mutate(name_place = str_c(first_name, location, sep = "_")) 
```


## Casing

Once we've concatenated some strings there's a fair chance there will be something off with the formatting. When we're writing reports this is important: the meaning of words **may** make sense, but a missing capital letter or unexpectedly capitalised word can have a huge effect on the meaning of a sentence and the aesthetics of the report. It's arguably even more important when working with a dataset.

`stringr` has a few methods which will let us manipulate the casing of a string. Because `stringr` is part of the tidyverse, we can use the `magrittr` pipes if we wish!

```{r}
pangram <- "The quick brown fox jumps over the lazy dog"

# All letters upper-case
pangram %>%
  str_to_upper()

# All letters lower-case
pangram %>%
  str_to_lower()

# Formatted as a title
pangram %>%
  str_to_title()

# Formatted as a sentence
pangram %>%
  str_to_sentence()
```

We can use these to fix any  issues with people not capitalising their names (we're looking at you Steven!):

```{r}
employees %>%
  select(first_name, last_name) %>%
  mutate(first_name_fixed = str_to_title(first_name)) %>%
  mutate(last_name_fixed = str_to_title(last_name))
```

## Splitting

We've stuck some strings together, but how do we undo the damage? As you might expect, `stringr` includes a handy method to do just that: `str_split()`.

`str_split()` always takes two arguments: the string we want to split up, and a string to indicate where we want the break(s) to occur. It will return a `list` of character vectors. Let's start with another short phrase:

```{r}
unbroken_string <- "We're going to break this string up."
```

We might, for example, want to create a vector of the individual words in that phrase. In that case we want to split the phrase around the whitespace between words:

```{r}
unbroken_string %>%
  str_split(" ") %>%
  flatten_chr()
```

See how we now have a `list` containing a vector of words, which we then `flatten` to a vector? Note that the whitespace hasn't been included in the output; it's been discarded completely. In any instance where we split a string around a given character or around patterns in the string using **regular expression** (more on them this afternoon).

Finally, what happens if we don't specify a character to split around and just pass in the empty string?

```{r}
unbroken_string %>%
  str_split("") %>%
  flatten_chr()
```

We get back a vector of all the individual characters in the string, including the whitespace and punctuation. This might seem like a strange thing to do, but it can be a very useful tool and is actually what's going on under the lid in some programming languages when doing things like reversing strings.

If you wanted to use `str_split` in a dataset it's not that easy, as it creates a list by default. Which you then have to get out of list format. For example:

```{r}
employees %>% 
  mutate(postcode_new = str_split(postcode, " "))
```

You'll see that our `postcode_new` variable contains a list. If we want to get it out of that, we need to add in a command to `unnest` the list. 

```{r}
employees %>% 
  mutate(postcode_new = str_split(postcode, " ")) %>% 
  unnest(postcode_new)
```

But even that doesn't really do what we want, as it separates out the postcode into two lines for each person. 

If you wanted to split a column in your dataset, say we wanted to split the postcodes into the inner and outer postcode areas, you may be better using `seperate` from `tidyr` which you learnt about in tidy data:

```{r}
employees %>%
  separate(postcode, c("postcode_outer", "postcode_inner"), " ")
```

Additionally `cSplit` from `splitstackshape` is useful if you don't know many splits you're going to find in the data (although in our case we know every case is split into 2). 

<blockquote class='task'>
**Task - 10 mins** 

* Concatenate the strings `"Manipulating" "strings" "is" "fun!"`
* Capitalise the result and save it in a new variable
* Split the formatted string into individual characters

<br>

<details>
<summary>**Solution**</summary>
```{r}
# Concatenate
built_string <- str_c("Manipulating", "strings", "is", "fun!", sep = " ")
built_string

# Format
formatted_string <- built_string %>%
  str_to_upper()

# Split
formatted_string %>%
  str_split("")
```
</details>
</blockquote>


## Finding substrings

Perhaps we don't want to break a string down totally; maybe we just want to grab a section of it to work with. When we grab a piece of a string like this we refer to it as a **substring**. We can start and finish the substring wherever we like, and can even use vectors to extract many substrings at once.

This afternoon we will learn how to detect/extract substrings based on the text/pattern but for this lesson we will be doing it based on position.

Let's start again with an initial string:
```{r}
full_string <- "Let's grab a substring from this!"
```

To find a substring we use `str_sub` and pass it three arguments: the string we're starting with, our desired start point for a substring and its end point. If we include `str_sub()` as part of a pipe, this takes care of the first data argument for us. So, to get the word "Let's" from `full_string` we'd start at index 1 (`start` argument) and finish at 5 (`end` argument):

```{r}
full_string %>%
  str_sub(start = 1, end = 5)
```

We don't even have to say specify where we want to finish the substring. The default for the `end` argument is the end of the string so if we wanted a substring which excluded the first _n_ characters of a string we could set `start` at the index _n + 1_ and omit the `end` argument (which will go to default):

```{r}
full_string %>%
  str_sub(start = 6)
```

That will essentially chop the first word off, and only take from position 6. 

Say we wanted to find the last five characters of a bunch of strings. If the strings are all different lengths then we have a problem: how do we know what the start and end indices are? Using `stringr` we have another option:

```{r}
full_string
  str_sub(-5, -1)
```

By passing in **negative** indices we can tell R to count back from the end of the string. In this case we want to start five characters from the end of the string and finish with the final character.

We can use as another method to extract the outer and inner parts of the postcode. The outer parts differ in length but the inner is always 3 characters long so we can use negative indices:

```{r}
employees %>%
  mutate(postcode_inner = str_sub(postcode, -3)) %>%
  mutate(postcode_outer = str_sub(postcode, 1, -4))
```

We will learn later how you could do this another way by detecting the 'space' inbetween the inner and outer postcodes using pattern detection. 


## Replacing substrings

`str_sub()` has more uses than simply extracting substrings, we can also use it to help us replace parts of a string. 

```{r}
original_string <- "We're going to replace some words."
original_string
```

We start off by using `str_sub()` to find a substring as before, but instead of simply returning the value, we assign a new string to the substring we define using indices:

```{r}
str_sub(original_string, 1, 22) <- "I've changed"
original_string
```

We'll learn this afternoon about ways we can replace substrings within columns of a dataframe. 


# Numbers in strings

We said at the start that we would often be working with numbers, and we'll still want to include them in our reports. We can't manipulate them in the same way though, unless we first format them correctly.

That's where the `format()` function comes in. By passing in a number we can convert it to a string, which we can then use all our favourite string functions on:

```{r}
number <- 123456.789

number %>%
  format()
```

Note the quote marks telling us that our number is now a string. You'll also see that it's been rounded to one decimal point. We can configure that value using the `nsmall` parameter, with the default being 1:

```{r}
number %>%
  format(nsmall = 2)

number %>%
  format(nsmall = 1)

number %>%
  format(nsmall = 10)
```

We can also configure the decimal point we want to use (since in different countries different symbols are used):

```{r}
number %>%
  format(nsmall = 3, decimal.mark = ",")
```

Finally we can break the number down into comma-separated blocks, with both the commas and the size of the blocks being configurable:

```{r}
number %>%
  format(nsmall = 3, big.mark= ",", big.interval = 3)
```

This kind of formatting wouldn't be appropriate if you want to apply mathematics on the values as they are now a string type rather than numeric but it's useful for making the values more aesthetic (for example if you were to present the values in a table in a report). 

<blockquote class='task'>
**Task - 10 mins** 

Here are some more questions for you to practice with. Remember, the point of these questions is not to do something that makes sense for this dataset, but rather to allow you to practice using the techniques we've learnt today on a real dataset. When it comes to your projects, you will be in charge of deciding how to work with the strings in your dataset. 

We are going to use some Spotify data for this task:
```{r, message=FALSE, warning=FALSE}
spotify_songs <- read_csv("data/spotify_sample.csv")
```

* Upcase the text in the `playlist_name` column. Overwrite the existing column to store the result. 
* Lowcase the text in the `track_artist` column. Store the result in a new column called `track_artist_lowcase`.  
* Take the first 5 characters of the `playlist_id` column, and save it in a new column called `playlist_start`. 
* Take the first 4 characters of the `track_album_release_date` column and save it in a new column called `year`.  
* What else can you do to this dataset to practice? Can you work with the numbers? This is open ended - have fun!

<br>
<br>

<details>
<summary>**Solution**</summary>

```{r}
# upcase the playlist name
spotify_songs %>%
  mutate(playlist_name = str_to_upper(playlist_name))

# lowcase track artist
spotify_songs %>%
  mutate(track_artist_lowcase = str_to_lower(track_artist))

# take the first 5 characters of the playlist id
spotify_songs %>%
  mutate(playlist_start = str_sub(playlist_id, 1, 5))

# Take the first 4 characters of the `track_album_release_date` column and save it in a new column called `year`.  
spotify_songs %>%
  mutate(year = str_sub(track_album_release_date, 1, 4))
```
</details>
</blockquote>




# Recap

* What would happen if we put an apostrophe in a single-quoted string?
<details>
<summary>**Answer**</summary>
It would break unless we used the escape character
</details>

<br>

* What happens to NULL values passed to `str_c`?
<details>
<summary>**Answer**</summary>
They are ignored
</details>

<br>

* What do negative indices do when passed in to `str_sub`?
<details>
<summary>**Answer**</summary>
Allow us to count back from the end of the string
</details>

<br>



# Additional Resources

* [String Functions in R](https://www.r-bloggers.com/string-functions-in-r/)
* [Handling and Processing Strings in R](https://www.gastonsanchez.com/Handling_and_Processing_Strings_in_R.pdf)
* [Formatting Numbers in R](https://www.dummies.com/programming/r/how-to-format-numbers-in-r/)
* [stringr documentation](https://stringr.tidyverse.org/reference/)

